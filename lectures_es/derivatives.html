<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Espen Sirnes">
<meta name="dcterms.date" content="2025-03-24">

<title>Derivatives</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="derivatives_files/libs/clipboard/clipboard.min.js"></script>
<script src="derivatives_files/libs/quarto-html/quarto.js"></script>
<script src="derivatives_files/libs/quarto-html/popper.min.js"></script>
<script src="derivatives_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="derivatives_files/libs/quarto-html/anchor.min.js"></script>
<link href="derivatives_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="derivatives_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="derivatives_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="derivatives_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="derivatives_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="derivatives.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li><li><a href="derivatives.ipynb" download="derivatives.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Derivatives</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Espen Sirnes </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 24, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>This note provides an introduction to derivative pricing. In finance, a derivative is an asset or contract whose value depends on another asset. Consequently, the value of a derivative is a function of the underlying asset’s value. If the value of the underlying share is known, the exercise value of an option can be determined immediately.</p>
<p>One of the most common types of derivatives is options. We will begin by exploring how options are priced and later demonstrate how the principles of option pricing extend to a wide range of other derivatives.</p>
<section id="options" class="level1">
<h1>Options</h1>
<p>An option is a right but not an obligation to buy or sell an asset for a certain price. Options can be used for both hedging as well as speculation.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/optionvalue.png" class="img-fluid figure-img"></p>
<figcaption>Option Value</figcaption>
</figure>
</div>
<section id="the-cash-flow-from-an-option" class="level2">
<h2 class="anchored" data-anchor-id="the-cash-flow-from-an-option">The cash flow from an option</h2>
<p>There are mainly two types of options - put and call options. A call option gives you the right to buy one share at a fixed price sometime in the future. Let us say that the price agreed upon for an Equinor share is 105. This is called the strike price or exercise price. If the share price is 115 today, you can take advantage of your right to buy it for 105 and sell it in the market for 115. The value of the option is then 15.</p>
<p>However, if the market price is 95, it would be pointless to buy the stock for 105. Since you do not have any obligation to buy it, you would not exercise your right since that would lead to a certain loss. Therefore, the option price can never be negative, since the right to buy will never be exercised if it leads to a loss. Hence, if C is the value of the call, S the value of the stock, and X the strike price at the terminal date, we have</p>
<p><span id="eq-C"><span class="math display">\[
C = \max(S - X, 0)
\tag{1}\]</span></span></p>
<p>The share price is 115 option holder is thus left with <span id="eq-C_gain"><span class="math display">\[
= \max(115-105, 0) = 10
\tag{2}\]</span></span> But if the price falls to 95, the option loses its entire value <span id="eq-C_loss"><span class="math display">\[
= \max(95-105, 0) = 0
\tag{3}\]</span></span></p>
<p>Let us draw this up in a chart where X is the strike price, with a python function giving the maximum betseen the current share price and <span class="math inline">\(S-X\)</span></p>
<div id="cell-fig-call_option" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="dv">105</span>  <span class="co"># strike price</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the cash flow</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_canvas(title):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> np.linspace(<span class="dv">80</span>, <span class="dv">120</span>, <span class="dv">100</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create figure and axis objects</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the call option payoff</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    ax.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>, </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                                      linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    ax.axvline(X, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                        label<span class="op">=</span><span class="ss">f"Strike Price (X=</span><span class="sc">{</span>X<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Labels and title</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">"Stock Price (S)"</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">"Payoff"</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return figure, axis, and stock price</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ax, S  </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>ax, S <span class="op">=</span> create_canvas(<span class="st">"Cash Flow of a Call Option"</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>call_payoff <span class="op">=</span> np.maximum(S <span class="op">-</span> X, <span class="dv">0</span>) <span class="co">#call option payoff</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>ax.plot(S, call_payoff, label<span class="op">=</span><span class="st">"Call Option Payoff"</span>, </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>                                          linewidth<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-call_option" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-call_option-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="derivatives_files/figure-html/fig-call_option-output-1.png" width="659" height="449" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-call_option-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Call option cash flow
</figcaption>
</figure>
</div>
</div>
</div>
<p>Such drawings of the cash flow are called profit charts.</p>
<p>We have now examined how a call option works. A put option, on the other hand, is the right but not the obligation to sell an asset at a specified price. This means the option holder benefits from a falling share price and receives the difference between the market price S and the strike price X when the market price is lower than X. If the price is higher, the option has no value, and the owner gains nothing.</p>
<p>This is illustrated in <a href="#fig-put_option" class="quarto-xref">Figure&nbsp;2</a>. To represent the put option, we simply modify the function from <code>np.maximum(S - X, 0)</code> to <code>np.maximum(X - S, 0)</code>, reflecting the fact that the option gains value when the stock price decreases.</p>
<div id="cell-fig-put_option" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ax, S <span class="op">=</span> create_canvas(<span class="st">"Cash Flow of a Put Option"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>put_payoff <span class="op">=</span> np.maximum(X <span class="op">-</span> S, <span class="dv">0</span>) <span class="co">#put option payoff</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>ax.plot(S, put_payoff, label<span class="op">=</span><span class="st">"Put Option Payoff"</span>, </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                                        linewidth<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-put_option" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-put_option-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="derivatives_files/figure-html/fig-put_option-output-1.png" width="659" height="449" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-put_option-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Put option cash flow
</figcaption>
</figure>
</div>
</div>
</div>
<p>Thus, we see that the immediate exercise value of an option is the difference between the share price and the exercise price X. In the case of a put option, there is no payment when the share price is greater than X, while for a call option, the option is worthless when the stock price is lower than X.</p>
</section>
<section id="value-before-expiration" class="level2">
<h2 class="anchored" data-anchor-id="value-before-expiration">Value before expiration</h2>
<p>In general, it is never advantageous to exercise an option early, before the expiration date. This is because an option always has some value beyond its immediate exercise value, as there is always a chance it will become more valuable. This is due to a principle known as “<em>Jensen’s Inequality</em>” <span class="citation" data-cites="jensen1906">(<a href="#ref-jensen1906" role="doc-biblioref">Jensen 1906</a>)</span>. It states that the mean of a convex function is always higher than the function of the mean.</p>
<p>This is illustrated in <a href="#fig-jensen" class="quarto-xref">Figure&nbsp;3</a>. Here, we see that if the stock price can take two values, 95 and 115, the option value at the mean of these two points is zero, since this corresponds to the exercise price. However, if we take the mean of the call function values, it is the average of 15 and 0, which equals 7.5. Hence, the mean of a convex function is higher than the function at the mean.</p>
<div id="cell-fig-jensen" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ax, S <span class="op">=</span> create_canvas(<span class="st">"Jensens inequality"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>call_payoff <span class="op">=</span> np.maximum(S <span class="op">-</span> X, <span class="dv">0</span>) <span class="co">#call option payoff</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>ax.plot(S, call_payoff, label<span class="op">=</span><span class="st">"Call Option Payoff"</span>, </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                                        linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate two stock prices, one to the left and one</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">#  to the right of the strike price</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>S_left <span class="op">=</span> <span class="dv">95</span>  <span class="co"># 5 units below strike price</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>S_right <span class="op">=</span> <span class="dv">115</span>  <span class="co"># 15 units above strike price</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute corresponding payoffs</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>payoff_left <span class="op">=</span> np.maximum(S_left<span class="op">-</span>X, <span class="dv">0</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>payoff_right <span class="op">=</span> np.maximum(S_right <span class="op">-</span> X, <span class="dv">0</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute mean stock price and corresponding mean </span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># payoff</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>S_mean <span class="op">=</span> (S_left <span class="op">+</span> S_right) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>payoff_mean <span class="op">=</span> (payoff_left <span class="op">+</span> payoff_right) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Add scatter points illustrating the two sample </span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co"># payoffs</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>ax.scatter([S_left, S_right],[payoff_left,payoff_right], </span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>      color<span class="op">=</span><span class="st">'blue'</span>, label<span class="op">=</span><span class="st">"Sampled Payoffs"</span>, zorder<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw a line between the two points to indicate the </span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co"># mean of </span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="co"># payoffs</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>ax.plot([S_left,S_right], [payoff_left,payoff_right], </span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span><span class="st">'blue'</span>, linestyle<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Scatter point for the payoff at the mean stock price</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>ax.scatter(S_mean, payoff_mean, color<span class="op">=</span><span class="st">'blue'</span>,</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span><span class="st">'X'</span>, label<span class="op">=</span><span class="st">"Mean of call payoff"</span>, zorder<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>ax.scatter(S_mean, <span class="dv">0</span>, color<span class="op">=</span><span class="st">'red'</span>, </span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span><span class="st">'X'</span>, label<span class="op">=</span><span class="st">"Call payoff of mean"</span>, zorder<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Annotate points</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>ax.text(S_mean <span class="op">-</span> <span class="dv">1</span>, payoff_mean, <span class="st">"E[call_payoff(S)]"</span>, </span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>                          ha<span class="op">=</span><span class="st">'right'</span>, </span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>                          fontsize<span class="op">=</span><span class="dv">10</span>, </span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>                          color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">106</span>, <span class="dv">1</span>, <span class="st">"{"</span>, </span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>                          ha<span class="op">=</span><span class="st">'right'</span>, </span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>                          fontsize<span class="op">=</span><span class="dv">90</span>, </span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>                          color<span class="op">=</span><span class="st">'grey'</span>, </span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>                          fontweight<span class="op">=</span><span class="st">'ultralight'</span>, </span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>                          fontname<span class="op">=</span><span class="st">"serif"</span>)</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">102</span>, <span class="dv">2</span>, <span class="st">"Intrinsic value"</span>, </span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>                          ha<span class="op">=</span><span class="st">'right'</span>, </span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>                          fontsize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>ax.text(S_mean <span class="op">+</span> <span class="dv">1</span>, <span class="fl">0.5</span>, <span class="st">"call_payoff(E[S])"</span>, </span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>                          ha<span class="op">=</span><span class="st">'left'</span>, </span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>                          fontsize<span class="op">=</span><span class="dv">10</span>, </span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>                          color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Show updated plot</span></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>ax.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-jensen" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-jensen-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="derivatives_files/figure-html/fig-jensen-output-1.png" width="659" height="449" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-jensen-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Jensens inequality illustrated by a call option
</figcaption>
</figure>
</div>
</div>
</div>
<p>This means that if there is a long time until the expiration date, an option will still have some value, even if the price is lower than the exercise price, because there is always a possibility that the option will become profitable before it expires. As a result, the value of an option is higher before the expiration date than at the expiration date.</p>
</section>
<section id="notation" class="level2">
<h2 class="anchored" data-anchor-id="notation">Notation</h2>
<p>The value of a call option before expiration is denoted as <span class="math inline">\(C_t\)</span>, while the value of a put option is denoted as <span class="math inline">\(P_t\)</span>. Sometimes, it is useful to have a general symbol for the option price, regardless of whether it is a put or a call. In such cases, the general value of an option or derivative is represented as <span class="math inline">\(f_t\)</span>. The stock price is denoted as <span class="math inline">\(S_t\)</span>, and the exercise price is <span class="math inline">\(X\)</span> (exercise value). The variable <span class="math inline">\(t\)</span> represents the time since the option was issued, measured in years. For example, if the option was issued three months ago, then <span class="math inline">\(t = \frac{1}{4}\)</span>.</p>
<p>The buyer has the right to exercise the option for a limited period. The time when the option expires is called the expiration date and is represented by capital <span class="math inline">\(T\)</span>. If the option lasts for one year, then <span class="math inline">\(T = 1\)</span>. The exercise values of the options at expiration are denoted as <span class="math inline">\(C_T\)</span> or <span class="math inline">\(P_T\)</span>.</p>
</section>
<section id="black-and-scholes-formula" class="level2">
<h2 class="anchored" data-anchor-id="black-and-scholes-formula">Black and Scholes formula</h2>
<p>So, how much is an option worth? The relationship between an option’s value and the underlying stock price makes it possible to derive a formula that determines the value of the right the option represents. This formula, discovered in the early 1970s, is known as the Black-Scholes-Merton option-pricing formula <span class="citation" data-cites="scholes1973pricing">Merton et al. (<a href="#ref-merton1971theory" role="doc-biblioref">1971</a>)</span>. However, it was later found to be closely related to earlier work by <span class="citation" data-cites="bachelier1900">Bachelier (<a href="#ref-bachelier1900" role="doc-biblioref">1900</a>)</span>.</p>
<p>The Black-Scholes formula is one of the most significant innovations in finance and is used daily in global financial markets. The economists behind the formula were awarded the Nobel Prize in 1997 for their contribution. While we will return to the details of the Black-Scholes formula later, you might be interested in seeing how it is calculated now.</p>
<p>In <a href="#fig-bs" class="quarto-xref">Figure&nbsp;4</a>, we see the Black-Scholes price overlaid on the profit chart.</p>
<div id="cell-fig-bs" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>ax, S <span class="op">=</span> create_canvas(<span class="st">"Black &amp; Scholes price"</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>call_payoff <span class="op">=</span> np.maximum(S <span class="op">-</span> X, <span class="dv">0</span>) <span class="co">#call option payoff</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>ax.plot(S, call_payoff, </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="st">"Call Option value at expiration"</span>, </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> black_scholes_call(S, X, T, r, sigma):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>          (np.log(S <span class="op">/</span> X) <span class="op">+</span> (r <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> T) </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                                  <span class="op">/</span> (sigma <span class="op">*</span> np.sqrt(T))</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (S <span class="op">*</span> norm.cdf(d1) <span class="op">-</span> X <span class="op">*</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                                        <span class="op">*</span> norm.cdf(d2))</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">106</span>, <span class="fl">1.5</span> , <span class="st">"{"</span>, ha<span class="op">=</span><span class="st">'right'</span>, fontsize<span class="op">=</span><span class="dv">120</span>, </span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>                      color<span class="op">=</span><span class="st">'grey'</span>, </span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                      fontweight<span class="op">=</span><span class="st">'ultralight'</span>, </span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>                      fontname<span class="op">=</span><span class="st">"serif"</span>)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">101</span>, <span class="fl">2.4</span> , <span class="st">"Intrinsic value"</span>, ha<span class="op">=</span><span class="st">'right'</span>, </span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                                        fontsize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">110</span>, <span class="dv">13</span> , <span class="st">"$C_t$"</span>, ha<span class="op">=</span><span class="st">'left'</span>, </span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                                        fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">110</span>, <span class="dv">7</span> , <span class="st">"$C_T$"</span>, ha<span class="op">=</span><span class="st">'left'</span>, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>ax.plot(S,black_scholes_call(S, X, <span class="fl">0.25</span>, <span class="fl">0.05</span>, <span class="fl">0.37</span>), </span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>      label<span class="op">=</span><span class="st">"Black and Scholes option price today"</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>ax.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-bs" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="derivatives_files/figure-html/fig-bs-output-1.png" width="672" height="449" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Call option and Black&amp;Scholes option price
</figcaption>
</figure>
</div>
</div>
</div>
<p>The “intrinsic value” here, is then the Black and Scholes fair value in excess of the exercise price (value at expiration).</p>
<p><strong><em>Problems:</em></strong></p>
<ul>
<li><p>Change the Black and Scholes figure to show a put option. The formula for the Black and Scholes put is <span id="eq-bs_put"><span class="math display">\[
P(S, X, T, r, \sigma) = X e^{-rT} \Phi(-d_2) - S \Phi(-d_1)
\tag{4}\]</span></span> where <span id="eq-bs_put"><span class="math display">\[
d_1 = \frac{\ln(S / X) + \left(r + \frac{1}{2} \sigma^2 \right)T}{\sigma \sqrt{T}}
\tag{5}\]</span></span> and <span id="eq-bs_put"><span class="math display">\[
d_2 = d_1 - \sigma \sqrt{T}
\tag{6}\]</span></span></p>
<p><span class="math inline">\(\Phi\)</span> is the cumulative standard normal distribution function.</p></li>
<li><p>Which of the arguments in the Black and Scholes formula are most difficult to estimate?</p></li>
</ul>
</section>
<section id="european-and-american-options" class="level2">
<h2 class="anchored" data-anchor-id="european-and-american-options">European and American options</h2>
<p>Sometimes an option can be exercised at any time up to the terminal date. We therefore distinguish between two types of options:</p>
<ul>
<li><strong>American option</strong>: The option holder can choose whether to exercise the option at any time before the terminal date.</li>
<li><strong>European option</strong>: The option can only be exercised on the terminal date.</li>
</ul>
<p>In addition to buying options, investors may also sell options short in the market, a process known as issuing options. In this case, the cash flow will be the exact opposite of what the buyer receives, as illustrated below. The buyer (owner) receives the same cash flow as previously shown, while the seller has an obligation rather than a right. Therefore, the issuer’s cash flow is a mirror image of the buyer’s.</p>
</section>
<section id="put-call-parity" class="level2">
<h2 class="anchored" data-anchor-id="put-call-parity">Put-call parity</h2>
<p>As you may have noticed, a put option always provides a payout when a call option does not (and vice versa), assuming the strike price is the same. By combining both types of options, an investor can create a cash flow proportional to the share price, regardless of how the share price changes. This relationship between a put, a call, and the share price is known as <strong>put-call parity</strong>:</p>
<p><span id="eq-put_call_parity"><span class="math display">\[
S_{t} - PV_{t}(X) = C_{t} - P_{t}
\tag{7}\]</span></span></p>
<p>Where <span class="math inline">\(PV_{t}(X)\)</span> is the present value at time <span class="math inline">\(t\)</span>. As we see, this formula applies at any time, including before the terminal date <span class="math inline">\(T\)</span>.</p>
<p>In the figure below, we see the cash flow for a call option (<span class="math inline">\(+C_t\)</span>) and an issued put (<span class="math inline">\(-P_t\)</span>) plotted. The dotted line represents the combined value of these two positions, that is, the value of <span class="math inline">\(C_t - P_t\)</span>, along with the stock price <span class="math inline">\(S\)</span> itself.</p>
<p>If the date is before the terminal date, we use the present value of the exercise price at that time, <span class="math inline">\(PV_{t}(X)\)</span>. However, for now, we assume the terminal exercise price <span class="math inline">\(X\)</span> that has been used throughout.</p>
<p>The call-put and <span class="math inline">\(S - X\)</span> positions in <a href="#fig-put_call_par" class="quarto-xref">Figure&nbsp;5</a> are shifted up and down by 1 to make all lines visible.</p>
<div id="cell-fig-put_call_par" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ax, S <span class="op">=</span> create_canvas(<span class="st">"Put-call parity"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>call_payoff <span class="op">=</span> np.maximum(S <span class="op">-</span> X, <span class="dv">0</span>) <span class="co">#call option payoff</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>put_payoff <span class="op">=</span> np.maximum(X<span class="op">-</span>S, <span class="dv">0</span>) <span class="co">#call option payoff</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>ax.plot(S, call_payoff, label<span class="op">=</span><span class="st">"Call Option Payoff"</span>, </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>                                        linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>ax.plot(S, <span class="op">-</span>put_payoff, label<span class="op">=</span><span class="st">"Put Option Payoff"</span>, </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                                        linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>ax.plot(S, call_payoff<span class="op">-</span>put_payoff <span class="op">+</span> <span class="dv">1</span>, </span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="st">"$C_t-P_t$ Payoff"</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>ax.plot(S, S<span class="op">-</span>X <span class="op">-</span> <span class="dv">1</span>, label<span class="op">=</span><span class="st">"$S-X$ Payoff"</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>ax.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-put_call_par" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-put_call_par-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="derivatives_files/figure-html/fig-put_call_par-output-1.png" width="670" height="449" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-put_call_par-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Put-call parity
</figcaption>
</figure>
</div>
</div>
</div>
<p>The minus sign before the put option means that we hold it <em>short</em>. This means that we sell it. In financial markets, we do not need to own an asset to sell it. Instead, we can <em>short</em> it, which involves borrowing the asset and later returning it.</p>
<p>For example, we may borrow a stock for three months, sell it in the market, and hope that its price decreases before we buy it back to return it. Shorting means that we hold a negative amount of the asset and are speculating on a price decrease.</p>
<p>For options, short selling can also mean <em>issuing</em> the option. Most online brokers allow traders to sell options without owning them first, provided that they post some collateral. This effectively means that the trader issues the option.</p>
</section>
<section id="combining-options" class="level2">
<h2 class="anchored" data-anchor-id="combining-options">Combining options</h2>
<p>By combining a put and a call, it is possible to replicate the cash flows of buying a share and taking out a loan. Additionally, one can buy and sell puts and calls with different exercise prices to create customized cash flows at different share prices.</p>
<p>In <a href="#fig-issue_call_put" class="quarto-xref">Figure&nbsp;6</a>, we have plotted the net cash flow from issuing both a call option (call) and a put option (put).</p>
<div id="cell-fig-issue_call_put" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ax, S <span class="op">=</span> create_canvas(<span class="st">"Issuing a call and put"</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>call_payoff <span class="op">=</span> np.maximum(S <span class="op">-</span> X, <span class="dv">0</span>) <span class="co">#call option payoff</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>put_payoff <span class="op">=</span> np.maximum(X<span class="op">-</span>S, <span class="dv">0</span>) <span class="co">#call option payoff</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ax.plot(S, <span class="op">-</span>call_payoff<span class="op">-</span>put_payoff<span class="op">+</span><span class="dv">8</span>, </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            label<span class="op">=</span><span class="st">"Issued call and put"</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>ax.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-issue_call_put" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-issue_call_put-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="derivatives_files/figure-html/fig-issue_call_put-output-1.png" width="670" height="449" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-issue_call_put-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Issued call and put
</figcaption>
</figure>
</div>
</div>
</div>
<p>As you can see, the options are slightly shifted up compared to how we have drawn them before. The reason for this is that we have now included the sales price of the options (the intrinsic value), which varies depending on the share price at the time. In this example, the share price is higher than the exercise price.</p>
<p>Since we have taken the intrinsic value of the option into account, we see that the option will provide a cash flow as long as the stock price is between a and b. This combination can therefore be used to bet that the price of a stock will remain within a certain range. For example, if one expects Equinor’s share price to be exactly 105 in six months, one could issue a put and a call between 95 and 105.</p>
<p>Similarly, options can be used to bet that the price will deviate from a specific target, either positively or negatively. You can draw the cash flow for this case yourself. The only limit to the cash flows that can be created with options is one’s imagination.</p>
<p><strong><em>Problem:</em></strong><br>
Try different combinations of call and put options, including those with different exercise values, to create sophisticated cash flows.</p>
</section>
</section>
<section id="binomial-options" class="level1">
<h1>Binomial options</h1>
<p>We will not delve deeply into the mathematics of derivatives in this course. Instead, the focus will be on developing an understanding of the fundamental principle behind derivative pricing—<em>risk-neutral expectation</em>—and how it can be used as a tool to price any derivative or contract written on an underlying asset.</p>
<p>To illustrate this principle, it is helpful to examine how <em>binomial options</em> are priced.</p>
<p>A binomial option is an option where the underlying price can take only two possible values. While this may seem like an oversimplification, we will soon see that this basic model provides valuable insight into the pricing of options in general.</p>
<section id="the-model" class="level2">
<h2 class="anchored" data-anchor-id="the-model">The model</h2>
<p>We will now consider a simplified scenario where the share price can take only two values in the future. We assume as previously that the Equinor share may either rise to 115 or fall to 95 from its current price of 100 kroner. The interest rate is 5%.</p>
<p>Further, assume that we need to determine the price of a call option with an exercise price of 105. This means that the owner has the right to receive 15 if the stock price rises, but nothing otherwise. Graphically, the problem can be represented as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/binom_opt.png" class="img-fluid figure-img"></p>
<figcaption>Option valueation</figcaption>
</figure>
</div>
<p>The task is to determine the current option price, denoted as <span class="math inline">\(f_0\)</span> in the figure above. We use <span class="math inline">\(f_0\)</span> instead of <span class="math inline">\(c_0\)</span> because we aim to develop a general pricing method that applies to both put and call options. In fact, this method can be used to price any derivative.</p>
<p>The key to solving this problem is recognizing that the same cash flow can be replicated by borrowing money to finance a fraction of the shares that the option delivers, regardless of whether the price goes up or down. The reason this replication is possible is that an option’s value is a function of the stock price. When the stock is worth 115, the option will always be worth 15. When the stock is worth 95, the option is always worthless. By substituting the stock price into this function, we can determine the value of the option.</p>
<p>Now, suppose we borrow money to purchase a certain number of shares per option, denoted by <span class="math inline">\(\Delta\)</span>. For example, if we buy half as many shares as options, then <span class="math inline">\(\Delta = \frac{1}{2}\)</span>. Since the stock price is 100, we buy shares worth:</p>
<p><span id="eq-delta_example"><span class="math display">\[
100 \cdot \Delta = 50
\tag{8}\]</span></span></p>
<p>per option. After half a year (<span class="math inline">\(T = \frac{1}{2}\)</span>), we must repay the loan with interest, so the total repayment amount will be:</p>
<p><span id="eq-repayment_example"><span class="math display">\[
100 \cdot 1.05^{\tfrac{1}{2}} \cdot \Delta
\tag{9}\]</span></span></p>
<p>If the share price rises, our account balance will then show a surplus of:</p>
<p><span id="eq-cf_up"><span class="math display">\[
\Delta \cdot (115 - 100 \cdot 1.05^{\tfrac{1}{2}})
\tag{10}\]</span></span></p>
<p>Similarly, we receive 15 on the option if the stock price goes up. If we buy the option for <span class="math inline">\(f_0\)</span> today and fund it with a loan equal amount <span class="math inline">\(f_0\)</span>, we will next year have:</p>
<p><span id="eq-option_up"><span class="math display">\[
10 - f_0 \cdot 1.05^{\tfrac{1}{2}}
\tag{11}\]</span></span></p>
<p>We can now select an appropriate proportion of shares <span class="math inline">\(\Delta\)</span> so that these two transactions provide identical cash flows. This means that we can find a fraction of shares <span class="math inline">\(\Delta\)</span> so that the leveraged purchase of <span class="math inline">\(\Delta\)</span> shares give the same return as a similar purchase of the option by solving the following equation for <span class="math inline">\(\Delta\)</span>: <span id="eq-no_arbitrage_up"><span class="math display">\[
\Delta \cdot (115 - 100 \cdot 1.05^{\tfrac{1}{2}}) = 10 - f_0 \cdot 1.05^{\tfrac{1}{2}}
\tag{12}\]</span></span></p>
<p>If the stock goes down, we can reason in exactly the same way. We get a loss of</p>
<p><span id="eq-cf_down"><span class="math display">\[
\Delta \cdot (95 - 100 \cdot 1.05^{\frac{1}{2}})
\tag{13}\]</span></span></p>
<p>on the share and a loss of</p>
<p><span id="eq-option_down"><span class="math display">\[
0 - f_0 \cdot 1.05^{\frac{1}{2}}
\tag{14}\]</span></span></p>
<p>on the option. We require that the investments should provide the same return, so we can set an equality between them:</p>
<p><span id="eq-no_arbitrage_down"><span class="math display">\[
\Delta \cdot (95 - 100 \cdot 1.05^{\frac{1}{2}}) = 0 - f_0 \cdot 1.05^{\frac{1}{2}}
\tag{15}\]</span></span></p>
<p>We now have two relatively simple equations with two unknowns, <span class="math inline">\(\Delta\)</span> and <span class="math inline">\(f_0\)</span>, which we can solve using sympy:</p>
<div id="4f410c09" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Re-import necessary libraries since execution state was reset</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sympy <span class="im">as</span> sp</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, Markdown</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define symbols</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>Delta, f0 <span class="op">=</span> sp.symbols(<span class="st">'Delta f0'</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the equations</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>eq1 <span class="op">=</span> sp.Eq(Delta <span class="op">*</span> (<span class="dv">95</span> <span class="op">-</span> <span class="dv">100</span> <span class="op">*</span> <span class="fl">1.05</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>)), <span class="dv">0</span> <span class="op">-</span> f0 <span class="op">*</span> <span class="fl">1.05</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>eq2 <span class="op">=</span> sp.Eq(Delta <span class="op">*</span> (<span class="dv">115</span> <span class="op">-</span> <span class="dv">100</span> <span class="op">*</span> <span class="fl">1.05</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>)), <span class="dv">10</span> <span class="op">-</span> f0 <span class="op">*</span> <span class="fl">1.05</span><span class="op">**</span>(<span class="dv">1</span><span class="op">/</span><span class="dv">2</span>))</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Solve for Delta and f0</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> sp.solve((eq1, eq2), (Delta, f0))</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Display the solution</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>display(Markdown(<span class="ss">f"$f_0=</span><span class="sc">{</span>sol[f0]<span class="sc">}</span><span class="ss">$"</span>))</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>display(Markdown(<span class="ss">f"$</span><span class="ch">\\</span><span class="ss">Delta=</span><span class="sc">{</span>sol[Delta]<span class="sc">}</span><span class="ss">$"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display cell-output-markdown">
<p><span class="math inline">\(f_0=3.64474653494468\)</span></p>
</div>
<div class="cell-output cell-output-display cell-output-markdown">
<p><span class="math inline">\(\Delta=0.500000000000000\)</span></p>
</div>
</div>
<p><span id="eq-delta_sol"><span class="math display">\[
\Delta = \tfrac{1}{2}
\tag{16}\]</span></span></p>
<p>and</p>
<p><span id="eq-f0_sol"><span class="math display">\[
f_0 \approx 3.645
\tag{17}\]</span></span></p>
<p>What we have done is find a combination of loans and equity investments that produce the same return as an equivalent position in the option. This is the fundamental principle behind all option pricing.</p>
<p>Thus, it is possible to achieve the same cash flows as the option by holding a fraction <span class="math inline">\(\Delta\)</span> of the share. This principle applies generally—an option can always be replicated by holding a portion of the stock. In fact, many banks profit by issuing options and hedging them through this replication strategy.</p>
</section>
<section id="a-general-binomial-formula" class="level2">
<h2 class="anchored" data-anchor-id="a-general-binomial-formula">A general binomial formula</h2>
<p>When the stock and option can only take two values, we call this the binomial option pricing model. While we could use the method above to calculate the option price every time, it is much easier to apply a more general formula. Let us introduce the following notation:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 8%">
<col style="width: 15%">
<col style="width: 21%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Today:</strong></th>
<th><strong>Expiration:</strong></th>
<th>Stock up</th>
<th>Stock down</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>The share price</strong></td>
<td><span class="math inline">\(S_0\)</span></td>
<td></td>
<td><span class="math inline">\(S_u\)</span></td>
<td><span class="math inline">\(S_d\)</span></td>
</tr>
<tr class="even">
<td><strong>Option Value</strong></td>
<td><span class="math inline">\(f_0\)</span></td>
<td></td>
<td><span class="math inline">\(f_u\)</span></td>
<td><span class="math inline">\(f_d\)</span></td>
</tr>
<tr class="odd">
<td><strong>Price Ratio</strong> <span class="math inline">\(S_T/S_0\)</span></td>
<td></td>
<td></td>
<td><span class="math inline">\(u = S_u/S_0\)</span></td>
<td><span class="math inline">\(d = S_d/S_0\)</span></td>
</tr>
</tbody>
</table>
<p>Here, the subscripts <em>u</em> and <em>d</em> represent the up and down movements of the stock, respectively. We use a general variable <span class="math inline">\(f\)</span> that can stand for both a put (<span class="math inline">\(P\)</span>) and a call option (<span class="math inline">\(C\)</span>). Additionally, we define two variables, <span class="math inline">\(u\)</span> and <span class="math inline">\(d\)</span>, which represent the relative movement of the stock price when it increases or decreases.</p>
<p>In our example, we are considering an option with a strike price <span class="math inline">\(X = 105\)</span>, where the stock can either rise to <span class="math inline">\(S_u = 115\)</span> or fall to <span class="math inline">\(S_d = 95\)</span> from <span class="math inline">\(S_0=100\)</span>. The interest rate is <span class="math inline">\(r=0.05\)</span> and time to expiration is <span class="math inline">\(T=0.5\)</span>, so</p>
<div id="24a6b111" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>S_u <span class="op">=</span> <span class="dv">115</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>S_d <span class="op">=</span> <span class="dv">95</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>S_0 <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>f_u <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>f_d <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> S_u<span class="op">/</span>S_0</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> S_d<span class="op">/</span>S_0</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, instead of using specific numbers, we generalize the approach from the previous section to find <span class="math inline">\(f_0\)</span>.</p>
<p>As before, the investor buys <span class="math inline">\(\Delta\)</span> shares and borrows <span class="math inline">\(\Delta \cdot S_0\)</span> to finance the purchase. Taking interest into account, the investor must repay</p>
<p><span id="eq-repay"><span class="math display">\[
\Delta \cdot S_0 \cdot (1 + r)^T
\tag{18}\]</span></span></p>
<p>after one year. If the stock price rises, the investor can sell the stock for <span class="math inline">\(S_u\)</span> in the market. The resulting profit will be:</p>
<p><span id="eq-up_delta_profit"><span class="math display">\[
\Delta\cdot(S_u - S_0 \cdot(1+r)^T)
\tag{19}\]</span></span></p>
<p>This should match the profit gained from financing the option purchase with a loan. The option provides a payoff of <span class="math inline">\(f_u\)</span> when the stock price rises. The loan that must be repaid consists of the initial purchase price plus interest, which is:</p>
<p><span id="eq-up_f_profit"><span class="math display">\[
f_0 \cdot (1 + r)^T
\tag{20}\]</span></span></p>
<p>Thus, the profit from the leveraged option purchase is:</p>
<p><span id="eq-up_f"><span class="math display">\[
f_u - f_0\cdot(1+r)^T
\tag{21}\]</span></span></p>
<p>As before, we choose now a share of shares so that the profits of shares and option price match. That is, we find a <span class="math inline">\(\Delta\)</span> such that: <span id="eq-up_equation"><span class="math display">\[
\Delta\cdot(S_u - S_0 \cdot(1+r)^T) = f_u - f_0\cdot(1+r)^T
\tag{22}\]</span></span></p>
<p>Exactly the same argument applies if the stock goes down, so in that case we need only replace subscript u with d:</p>
<p><span id="eq-down_equation"><span class="math display">\[
\Delta\cdot(S_d - S_0 \cdot(1+r)^T) = f_d - f_0\cdot(1+r)^T
\tag{23}\]</span></span></p>
</section>
<section id="risk-neutral-probability" class="level2">
<h2 class="anchored" data-anchor-id="risk-neutral-probability">Risk-neutral probability</h2>
<p>As in the previous section, we have two unknowns: the proportion of <span class="math inline">\(\Delta\)</span> shares and the option price <span class="math inline">\(f\)</span>, which can be easily solved. We will not go into the full derivation of the solution here. However, it turns out that the solution can be expressed in a relatively simple way using a variable <span class="math inline">\(q\)</span>, known as the “risk-neutral probability.” It is calculated as:</p>
<p><span id="eq-q_formula"><span class="math display">\[
q=\frac{(1+r)^T-d}{u-d}
\tag{24}\]</span></span></p>
<p><span class="math inline">\(q\)</span> is really just a tool for calculating the option price and is not actually a probability. However, it shares a key property with real probabilities in that it always lies between zero and one. We use it to compute an expectation in the same way as we do with normal probabilities.</p>
<p>It is called “risk-neutral” because if we apply it to the terminal values of the underlying stock (<span class="math inline">\(S_u\)</span> and <span class="math inline">\(S_d\)</span>), the expected value equals the current stock price plus interest:</p>
<p><span id="eq-q_expectation"><span class="math display">\[
\mathbb{E}_q[S_T] = S_u \cdot q + S_d \cdot (1-q) = S_0 \cdot (1+r)^T
\tag{25}\]</span></span></p>
<p>We can verify this with sympy:</p>
<div id="803a59f2" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define symbols</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>Su, Sd, S0, r, T, q <span class="op">=</span> sp.symbols(<span class="st">'Su Sd S0 r T q'</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> Su<span class="op">/</span>S0</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> Sd<span class="op">/</span>S0</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> ((<span class="dv">1</span><span class="op">+</span>r)<span class="op">**</span>T<span class="op">-</span>d)<span class="op">/</span>(u<span class="op">-</span>d)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># The expected stock price under risk neutral probability</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>sp.simplify(Su <span class="op">*</span> q <span class="op">+</span> Sd <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> q))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="9">
<p><span class="math inline">\(\displaystyle S_{0} \left(r + 1\right)^{T}\)</span></p>
</div>
</div>
<p>Once we find <span class="math inline">\(q\)</span>, the option price is simply given as the present value of the expected option value at exercise, where we use the risk-neutral probability <span class="math inline">\(q\)</span> as the probability of “up” and “down”.</p>
<p>The option price today is therefore:</p>
<p><span id="eq-gen_formula"><span class="math display">\[
f_0=\frac{q \cdot f_u + (1-q) \cdot f_d}{(1+r)^T}
\tag{26}\]</span></span></p>
<p>We have discounted the expected value because <span class="math inline">\(f_u\)</span> and <span class="math inline">\(f_d\)</span> are not present cash flows but represent cash flows at the terminal time <span class="math inline">\(T\)</span>.</p>
<p>The process for calculating the price of a binomial option is as follows:</p>
<ol type="1">
<li>Calculate <span class="math inline">\(u\)</span> and <span class="math inline">\(d\)</span></li>
<li>Calculate the risk-neutral probability <span class="math inline">\(q\)</span> (<a href="#eq-q_formula" class="quarto-xref">24</a>)</li>
<li>Calculate the present value of the expected option value using probability <span class="math inline">\(q\)</span> (<a href="#eq-gen_formula" class="quarto-xref">26</a>)</li>
</ol>
<p>Although we will not delve into the mathematics of more complex payoffs, this illustrates a remarkably general principle: any derivative — a financial security whose value depends on shares or other underlying assets — can be priced using a probability distribution that ensures a risk-neutral return for the stock.</p>
<p>Thus, the price of any derivative can be determined by defining an appropriate risk-neutral probability distribution.</p>
<p>Additionally, note how we defined the option—not by first specifying the exercise price, but simply by defining <span class="math inline">\(f_u\)</span> and <span class="math inline">\(f_d\)</span>. This demonstrates that our pricing method does not rely on the specific structure of an option. Instead, all that is required is the derivative’s payoff for a given payoff of the underlying asset.</p>
<p>In essence, this provides a general framework for pricing any contract written on an asset.</p>
</section>
<section id="option-delta" class="level2">
<h2 class="anchored" data-anchor-id="option-delta">Option delta</h2>
<p>Another important quantity is <span class="math inline">\(\Delta\)</span>, which represents the number of shares needed to replicate an option. It turns out that the delta is:</p>
<p><span id="eq-gen_delta_formula"><span class="math display">\[
\Delta=\frac{f_u-f_d}{S_u-S_d}
\tag{27}\]</span></span></p>
<p>The <span class="math inline">\(\Delta\)</span> is useful because it indicates how many shares you must buy to replicate the option. Since holding more shares increases risk, delta also serves as a measure of the risk inherent in the option.</p>
<p>Delta can also be used to achieve the same exposure as holding the underlying derivative. By frequently rebalancing so that your holdings in the underlying asset adjust proportionally to the delta—typically on a daily or weekly basis—your cash flow will closely mimic the exposure of the derivative.</p>
<p>This strategy is known as <em>“delta hedging”</em>, and it is the method banks use when issuing derivatives. By continuously adjusting their positions in the underlying asset, banks hedge these products to ensure they do not take on financial risk themselves.</p>
</section>
<section id="using-the-general-binomial-formula" class="level2">
<h2 class="anchored" data-anchor-id="using-the-general-binomial-formula">Using the General Binomial Formula</h2>
<p>Let us apply the numbers from our example to the general binomial formula to calculate the value of the option. We will then compare the result with the solutions <span class="math inline">\(\Delta = \tfrac{1}{2}\)</span> and <span class="math inline">\(f_0 \approx 3.645\)</span> obtained from solving the equations (<a href="#eq-no_arbitrage_up" class="quarto-xref">12</a>) and (<a href="#eq-no_arbitrage_down" class="quarto-xref">15</a>).</p>
<div id="84422e98" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, Markdown</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>S_u <span class="op">=</span> <span class="dv">115</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>S_d <span class="op">=</span> <span class="dv">95</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>S_0 <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>f_u <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>f_d <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> S_u<span class="op">/</span>S_0</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> S_d<span class="op">/</span>S_0</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> ((<span class="dv">1</span><span class="op">+</span>r)<span class="op">**</span>T<span class="op">-</span>d)<span class="op">/</span>(u<span class="op">-</span>d)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>f0 <span class="op">=</span> (q<span class="op">*</span>f_u<span class="op">+</span>(<span class="dv">1</span><span class="op">-</span>q)<span class="op">*</span>f_d)<span class="op">/</span>((<span class="dv">1</span><span class="op">+</span>r)<span class="op">**</span>T)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> (f_u<span class="op">-</span>f_d)<span class="op">/</span>(S_u<span class="op">-</span>S_d)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>display(Markdown(<span class="ss">f"$f_0=</span><span class="sc">{</span>f0<span class="sc">}</span><span class="ss">$"</span>))</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>display(Markdown(<span class="ss">f"$</span><span class="ch">\\</span><span class="ss">Delta=</span><span class="sc">{</span>delta<span class="sc">}</span><span class="ss">$"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display cell-output-markdown">
<p><span class="math inline">\(f_0=3.6447465349446806\)</span></p>
</div>
<div class="cell-output cell-output-display cell-output-markdown">
<p><span class="math inline">\(\Delta=0.5\)</span></p>
</div>
</div>
<p>Wich we see corresponds with the previous calculations.</p>
</section>
</section>
<section id="the-stock-price-process" class="level1">
<h1>The stock price process</h1>
<p>Before we explore how contracts on assets with continuous rather than binomial prices are valued, we must first understand how stock prices are modeled in modern finance. This modeling approach provides a practical way to describe stock price movements in mathematical terms.</p>
<p>Let us begin by plotting some actual intraday prices. The blue line in <a href="#fig-intraday" class="quarto-xref">Figure&nbsp;7</a> shows a snapshot of the intraday price movements for the Norwegian company Equinor on March 24, 2025.</p>
<div id="cell-fig-intraday" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.dates <span class="im">as</span> mdates</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Read the data</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(<span class="st">'data/'</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="st">'equinor_intraday_240325.csv'</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'TID'</span>] <span class="op">=</span> pd.to_datetime(df[<span class="st">'TID'</span>], </span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">format</span><span class="op">=</span><span class="st">'%H:%M:%S'</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.sort_values(<span class="st">'TID'</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>df<span class="op">=</span>df[df[<span class="st">'TID'</span>]<span class="op">&gt;=</span>pd.to_datetime(<span class="st">'9:00:00'</span>, </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>                            <span class="bu">format</span><span class="op">=</span><span class="st">'%H:%M:%S'</span>)]</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>df<span class="op">=</span>df[df[<span class="st">'TID'</span>]<span class="op">&lt;=</span>pd.to_datetime(<span class="st">'16:00:00'</span>, </span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>                            <span class="bu">format</span><span class="op">=</span><span class="st">'%H:%M:%S'</span>)] </span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_canvas():</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Create figure and axis objects</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">5</span>))</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Set major ticks to round hours every hour</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>  ax.xaxis.set_major_locator(mdates.HourLocator(interval<span class="op">=</span><span class="dv">1</span>))</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>  ax.xaxis.set_major_formatter(mdates.DateFormatter(<span class="st">'%H:%M'</span>))</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Rotate x-axis labels for readability</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>  plt.setp(ax.xaxis.get_majorticklabels(), rotation<span class="op">=</span><span class="dv">90</span>)</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Labels and title</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>  ax.set_xlabel(<span class="st">'Time'</span>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>  ax.set_ylabel(<span class="st">'Price'</span>)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>  ax.set_title(<span class="st">'Equinor Intraday Price'</span>)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ax</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> create_canvas()</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="co">#Plot the data</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>ax.plot(df[<span class="st">'TID'</span>], df[<span class="st">'PRIS'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-intraday" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-intraday-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="derivatives_files/figure-html/fig-intraday-output-1.png" width="816" height="475" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-intraday-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Intraday prices for Equinor
</figcaption>
</figure>
</div>
</div>
</div>
<p>We observe that the price appears to move almost continuously. However, if you modify the time window in the code—for example, from 13:00 to 13:05—you will notice that the movements are not continuous at all, but rather a sequence of discrete price changes.</p>
<p>Additionally, we see that stock prices take only certain values. For Equinor, the smallest price increment is NOK 0.05, meaning that stock prices move in discrete steps both in time and value. Despite this, assuming continuous time and continuous prices is mathematically convenient and serves as a reasonable approximation, especially over longer time intervals, such as an hour or more of trading.</p>
<p>Therefore, stock price movements are often modeled as a continuous process, which is the approach we will take in this lecture.</p>
<section id="modeling-the-stock-price" class="level2">
<h2 class="anchored" data-anchor-id="modeling-the-stock-price">Modeling the stock price</h2>
<p>Let us now examine how financial economists model stock prices to replicate actual price movements as closely as possible. In <a href="#fig-intraday_sim" class="quarto-xref">Figure&nbsp;8</a>, a stock price process is simulated using the standard approach in finance and presented alongside the actual stock price of Equinor.</p>
<div id="cell-fig-intraday_sim" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Simulation:</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Calculating the mean and volatility</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.log(df[<span class="st">'PRIS'</span>]).diff().mean()</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> np.log(df[<span class="st">'PRIS'</span>]).diff().std()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">#The Wiener process</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>dlnS <span class="op">=</span> (mu <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span> </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> sigma <span class="op">*</span> np.random.randn(<span class="bu">len</span>(df)))</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Ensuring the proces starts at the same point, </span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">#and calulating the level</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>dlnS[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'PRIS_sim'</span>] <span class="op">=</span> (df[<span class="st">'PRIS'</span>].iloc[<span class="dv">0</span>] </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                        <span class="op">*</span> np.exp(np.cumsum(dlnS)))</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">#plotting:</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> create_canvas()</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>ax.plot(df[<span class="st">'TID'</span>], df[<span class="st">'PRIS'</span>])</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>ax.plot(df[<span class="st">'TID'</span>], df[<span class="st">'PRIS_sim'</span>])</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>ax.legend([<span class="st">'Real'</span>, <span class="st">'Simulated'</span>], frameon<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-intraday_sim" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-intraday_sim-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="derivatives_files/figure-html/fig-intraday_sim-output-1.png" width="816" height="475" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-intraday_sim-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Intraday prices for Equinor
</figcaption>
</figure>
</div>
</div>
</div>
<p>The orange line in <a href="#fig-intraday_sim" class="quarto-xref">Figure&nbsp;8</a> represents simulated prices, meaning that each time the code is executed, the orange path will vary.</p>
<p>You can see this from the formula in <a href="#fig-intraday_sim" class="quarto-xref">Figure&nbsp;8</a>, but we will now take a closer look at how stock prices are typically modeled in finance. We start with a model based on the relative <em>geometric</em> change in stock prices. By relative geometric change, we mean to the log difference, defined as:</p>
<p><span id="eq-logdiff_def"><span class="math display">\[
\Delta \log(S_t) = \log(S_t) - \log(S_{t-1}) = \Delta s_t
\tag{28}\]</span></span></p>
<p>Alternatively, we could consider the <em>discrete percentage difference</em>:</p>
<p><span class="math display">\[
\Delta S_t / S_t
\]</span></p>
<p>However, using log differences instead of percentage differences has a key advantage: the latter is <em>not symmetric</em>. If a stock price increases by 10% and then decreases by 10%, it does not return to its original level. In contrast, with log differences, a 10% increase followed by a 10% decrease brings the stock price <em>exactly</em> back to its starting point.</p>
<p>Log differences are closely related to <em>continuous compounding</em> and the <em>exponential function</em>. Since the logarithm is the inverse of the exponential function, the following identity holds for any <span class="math inline">\(x\)</span>:</p>
<div id="8eff3014" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">23.434</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>np.exp(np.log(x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>23.434</code></pre>
</div>
</div>
<p>Thus, if we know the log change <span class="math inline">\(\Delta s_t\)</span> over a given period, it follows directly from (<a href="#eq-logdiff_def" class="quarto-xref">28</a>) that the stock price at time <span class="math inline">\(t\)</span> is given by:</p>
<p><span id="eq-price_log_diff"><span class="math display">\[
S_t = S_0 \cdot e^{s_t}
\tag{29}\]</span></span></p>
<p>The log change in stock price consists of three key components: <em>drift, volatility correction, and innovation</em>, which will now be explained in more detail:</p>
<section id="innovation" class="level3">
<h3 class="anchored" data-anchor-id="innovation">Innovation</h3>
<p>Since stock prices are not fully predictable, we need to introduce a random element. This randomness should be structured so that the variance increases proportionally with time. This assumption is reasonable because it implies that the stock price two months from now will have twice the variance — and thus twice the risk — of the stock price one month from now.</p>
<p>This simple assumption can be expressed as</p>
<p><span id="eq-wiener"><span class="math display">\[
z_{t} = \varepsilon_{t}\sqrt{t}
\tag{30}\]</span></span></p>
<p>where <span class="math inline">\(\varepsilon_{t}\)</span> is standard normally distributed, <span class="math inline">\(\varepsilon_{t} \sim N(0,1)\)</span>, meaning it has a mean of zero and variance of one.</p>
<p>The standard random variable is multiplied by the square root of <span class="math inline">\(t\)</span>, ensuring that:</p>
<p><span id="eq-var_deltaz"><span class="math display">\[
Var(z_t) = t
\tag{31}\]</span></span></p>
<p>A random variable that increases in variance with time is called a Wiener Process. The further into the future, the less we know about the stock price.</p>
<p>The actual innovation also has a scale parameter <span class="math inline">\(\sigma\)</span>, so that the innovation to the price becomes:</p>
<p><span id="eq-sigma_zt"><span class="math display">\[
\sigma \cdot z_t
\tag{32}\]</span></span></p>
<p>The associated variance is proportional to the time period:</p>
<p><span id="eq-var_sigma_zt"><span class="math display">\[
var(\sigma \cdot z_t) = \sigma^2 \cdot t
\tag{33}\]</span></span></p>
<p>When simulating, we want to draw each innovation in the process <span class="math inline">\(z_t\)</span>, in other words, we want to draw the change in <span class="math inline">\(z_t\)</span>. Change is as usual indicated by <span class="math inline">\(\Delta\)</span>, so that the innovation per observation becomes</p>
<p><span id="eq-sigma_delta_zt"><span class="math display">\[
\sigma \cdot \Delta z_t
\tag{34}\]</span></span></p>
<p>The associated variance is then:</p>
<p><span id="eq-var_deltaz"><span class="math display">\[
var(\sigma \cdot \Delta z_t) = \sigma^2 \cdot \Delta t
\tag{35}\]</span></span></p>
<p>This means that the variance of each period in the Wiener Process <span class="math inline">\(z_t\)</span> is directly proportional to the length of the period.</p>
<p>In the specific dataset used for <a href="#fig-intraday" class="quarto-xref">Figure&nbsp;7</a>, the time intervals between observations vary because the data is based on transaction records. The time period is determined by the actual time elapsed between consecutive data points. However, in most financial models, <span class="math inline">\(\Delta t\)</span> is typically assumed to be constant.</p>
<p>For simplicity, in the simulation shown in <a href="#fig-intraday_sim" class="quarto-xref">Figure&nbsp;8</a>, we assume that the time step between observations is fixed at <span class="math inline">\(\Delta t = 1\)</span>. To create a process that closely replicates Equinor’s price movements, we estimate the period volatility using the standard deviation of the log price differences between observations:</p>
<div id="aa20fbaa" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> np.log(df[<span class="st">'PRIS'</span>]).diff().std()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The implementation of the innovation term from (<a href="#eq-sigma_delta_zt" class="quarto-xref">34</a>) in the code is then:</p>
<div id="579fdda7" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">*</span> np.random.randn(<span class="bu">len</span>(df))<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here, <code>np.random.randn(len(df))</code> generates random draws from a standard normal distribution, representing <span class="math inline">\(\varepsilon_{t}\)</span>, while multiplying by <code>sigma</code> scales the randomness according to the estimated volatility of the stock price.</p>
</section>
<section id="drift" class="level3">
<h3 class="anchored" data-anchor-id="drift">Drift</h3>
<p>The stock price is expected to change by a certain percentage each period. This expectation is captured by a drift term <span class="math inline">\(\mu\)</span>, which represents the average rate of return per time unit. On average, the stock price is expected to increase by <span class="math inline">\(\mu \Delta t\)</span> in each period.</p>
<p>By combining this deterministic drift term with the stochastic Wiener process, we obtain the full stock price process.</p>
<p>In the code for <a href="#fig-intraday" class="quarto-xref">Figure&nbsp;7</a>, the drift term is estimated as the mean log price change of Equinor throughout the trading day:</p>
<div id="d4e3b056" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.log(df[<span class="st">'PRIS'</span>]).diff().mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Mathematicaly the drift can be written</p>
<p><span id="eq-logdiff_drift_innov"><span class="math display">\[
\mu \cdot \Delta t
\tag{36}\]</span></span></p>
<p>In the calculation of <a href="#fig-intraday" class="quarto-xref">Figure&nbsp;7</a>, <span class="math inline">\(\Delta t = 1\)</span></p>
</section>
<section id="volatility-correction" class="level3">
<h3 class="anchored" data-anchor-id="volatility-correction">Volatility Correction</h3>
<p>If we were to define the change in log price using only the drift and innovation terms, as in (<a href="#eq-logdiff_drift_innov" class="quarto-xref">37</a>) and (<a href="#eq-sigma_delta_zt" class="quarto-xref">34</a>), the cumulative log price change from time 0 to <span class="math inline">\(t\)</span> would be:</p>
<p><span id="eq-logdiff_drift_innov"><span class="math display">\[
s_t = \mu \cdot t + \sigma \cdot z_t
\tag{37}\]</span></span></p>
<p>Substituting this into the exponential price model from (<a href="#eq-price_log_diff" class="quarto-xref">38</a>) gives:</p>
<p><span id="eq-price_log_diff"><span class="math display">\[
S_t = S_0 \cdot e^{\mu \cdot t + \sigma \cdot z_t}
\tag{38}\]</span></span></p>
<p>However, as we previously discussed in <a href="#fig-jensen" class="quarto-xref">Figure&nbsp;3</a>, this expression ignores the effect of Jensen’s inequality. Because the exponential function is convex, the expected value of <span class="math inline">\(S_t\)</span> is greater than the expected value of the log price change:</p>
<p><span id="eq-incorrect_exp"><span class="math display">\[
\mathbb{E}[S_t] &gt; S_0 \cdot e^{\mu \cdot t}
\tag{39}\]</span></span></p>
<p>We do know, however, what accounts for this difference between the expectation of the function and the function of the expectation. By adding a correction term</p>
<p><span id="eq-volatility_correction"><span class="math display">\[
-\tfrac{1}{2} \sigma^2 t
\tag{40}\]</span></span></p>
<p>we can adjust for Jensen’s inequality exactly. That is, we know that</p>
<p><span id="eq-correct_exp"><span class="math display">\[
\mathbb{E}[S_t] = S_0 \cdot e^{\mu \cdot t - \tfrac{1}{2} \sigma^2 t}
\tag{41}\]</span></span></p>
</section>
<section id="putting-it-all-together" class="level3">
<h3 class="anchored" data-anchor-id="putting-it-all-together">Putting It All Together</h3>
<p>By combining the innovation term (<a href="#eq-sigma_delta_zt" class="quarto-xref">34</a>), the volatility correction term (<a href="#eq-volatility_correction" class="quarto-xref">40</a>), and the drift component from (<a href="#eq-logdiff_drift_innov" class="quarto-xref">37</a>), we arrive at a realistic model for the log change in stock price:</p>
<p><span id="eq-logdiff_model"><span class="math display">\[
\Delta s_t = \mu \cdot \Delta t - \tfrac{1}{2} \sigma^2 \Delta t + \sigma \cdot \Delta z_t
\tag{42}\]</span></span></p>
<p>This leads to the full model for the stock price at any point in time:</p>
<p><span id="eq-final_price_model"><span class="math display">\[
S_t = S_0 \cdot e^{\mu \cdot t - \tfrac{1}{2} \sigma^2 \cdot t + \sigma \cdot z_t}
\tag{43}\]</span></span></p>
<p>Using (<a href="#eq-logdiff_model" class="quarto-xref">42</a>), the Python implementation therefore becomes</p>
<div id="d8ec52c6" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>dlnS <span class="op">=</span> (mu <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span> </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> sigma <span class="op">*</span> np.random.randn(<span class="bu">len</span>(df)))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'PRIS_sim'</span>] <span class="op">=</span> (df[<span class="st">'PRIS'</span>].iloc[<span class="dv">0</span>] </span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>                        <span class="op">*</span> np.exp(np.cumsum(dlnS)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here, <code>np.cumsum(dlnS)</code> computes the cumulative sum of log changes across all observations in the dataset, giving the full simulated price path.</p>
</section>
</section>
</section>
<section id="risk-neutral-pricing" class="level1">
<h1>Risk neutral pricing</h1>
<p>In the original papers, the derivation of the Black and Scholes option pricing formula, uses som pretty fancy math and sophisticated theory. However, if we know that we can price any derivative using risk neutral expectations, it becomes easier to understand how derivatives are priced.</p>
<p>For example the Black-Scholes-Merton option pricing fomula can be obtained by applying risk netural pricing. That involves calculating this integral</p>
<p><span id="eq-bs_expectation_call"><span class="math display">\[
f_0 = e^{-rt} \int_{-\infty}^{\infty} \max \left( S_0 e^{(r - \tfrac{1}{2} \sigma^2)t + \sigma \sqrt{t} \epsilon} - X, 0 \right) \phi(\epsilon) d\epsilon
\tag{44}\]</span></span></p>
<p>Here - <span class="math inline">\(f_0\)</span> is the valuation - <span class="math inline">\(e^{-rT}\)</span>: Is the contnously compunded discount factor (time value of money). - <span class="math inline">\(S_t = S_0 e^{(r - \frac{1}{2} \sigma^2)T + \sigma \sqrt{T} \epsilon}\)</span> is the value of the option at time <span class="math inline">\(t\)</span> - <span class="math inline">\(X\)</span> is the strike price - <span class="math inline">\(\phi(\epsilon)\)</span> is the standard normal density function.</p>
<p>We will not go through the calculations in this course, but it turns out that the solution to this integral is the Black-Scholes-Merton call option formula:</p>
<p><span id="eq-bs_call"><span class="math display">\[
C(S, X, T, r, \sigma) = S \Phi(d_1) - X e^{-rT} \Phi(d_2)
\tag{45}\]</span></span></p>
<p>where</p>
<p><span id="eq-bs_call_d1"><span class="math display">\[
d_1 = \frac{\ln(S / X) + \left(r + \frac{1}{2} \sigma^2 \right)T}{\sigma \sqrt{T}}
\tag{46}\]</span></span></p>
<p>and</p>
<p><span id="eq-bs_call_d2"><span class="math display">\[
d_2 = d_1 - \sigma \sqrt{T}
\tag{47}\]</span></span></p>
<p><span class="math inline">\(\Phi\)</span> is the cumulative standard normal distribution function.</p>
<p>Here’s an improved version of your section for clarity, flow, and grammar, while keeping the technical content intact:</p>
<hr>
<section id="numerical-approximation" class="level2">
<h2 class="anchored" data-anchor-id="numerical-approximation">Numerical Approximation</h2>
<p>Knowing that we can price derivatives using risk-neutral expectations means that we can, in principle, determine the fair value of almost any contract written on tradable assets. The expected value is defined as the sum of outcomes (or events) weighted by their probabilities. For example, the expected value of a die roll is:</p>
<p><span id="eq-dice"><span class="math display">\[
(1+2+3+4+5+6) \cdot \frac{1}{6} = 3.5
\tag{48}\]</span></span></p>
<p>that is, each outcome multiplied by its probability, summed over all outcomes.</p>
<p>As mentioned above, when we are dealing with a continuous distribution such as the normal distribution, the discrete concept of a probability is replaced by the probability density <span class="math inline">\(\phi(x)\)</span> multiplied by a small interval <span class="math inline">\(dx\)</span>. The outcome is the derivative’s value, and the summation becomes an integral.</p>
<p>However, solving such integrals analytically is often difficult or impossible. In practice, it is therefore common to compute the integral numerically. This involves converting the continuous distribution into a discrete one, allowing us to approximate the integral using a finite sum over discrete probabilities and outcomes.</p>
<p>This discretization means dividing the range of outcomes into intervals and calculating the probability mass in each interval. In other words, we approximate the continuous probability density by a histogram-like representation.</p>
<p>This process is illustrated in <a href="#fig-nummerical_approx" class="quarto-xref">Figure&nbsp;9</a>. Each bar represents the probability of an outcome falling within a given interval. We can then approximate the expected value by multiplying each outcome <span class="math inline">\(x\)</span> by its associated probability, <span class="math inline">\(\phi(x) \cdot dx\)</span>, where <span class="math inline">\(dx\)</span> is the interval width. In this case, the range is defined as ±5 standard deviations, divided into 30 intervals.</p>
<div id="cell-fig-nummerical_approx" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> <span class="fl">0.15</span>  <span class="co"># Risk-free rate</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span>  <span class="co"># Volatility</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the range for x</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> width<span class="op">*</span>sigma<span class="op">/</span>((N<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="fl">0.5</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(mu <span class="op">-</span> <span class="dv">4</span><span class="op">*</span>sigma, mu <span class="op">+</span> width<span class="op">*</span>sigma, dx)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>x_fine <span class="op">=</span> np.linspace(mu <span class="op">-</span> width<span class="op">*</span>sigma, mu <span class="op">+</span> width<span class="op">*</span>sigma, <span class="dv">1000</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co"># PDF values</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> norm.pdf(x, mu, sigma)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>pdf_fine <span class="op">=</span> norm.pdf(x_fine, mu, sigma)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>plt.plot(x_fine, pdf_fine, label<span class="op">=</span><span class="st">'Normal PDF'</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>plt.bar(x, pdf, width<span class="op">=</span>dx, alpha<span class="op">=</span><span class="fl">0.5</span>, align<span class="op">=</span><span class="st">'center'</span>, label<span class="op">=</span><span class="st">'PDF * dx (approximation)'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Numerical Approximation of Expectation using PDF * dx'</span>)</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Density'</span>)</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-nummerical_approx" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-nummerical_approx-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="derivatives_files/figure-html/fig-nummerical_approx-output-1.png" width="949" height="566" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-nummerical_approx-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Nummerica approximation of normal distribution
</figcaption>
</figure>
</div>
</div>
</div>
<section id="a-simple-function-for-valuing-a-derivative" class="level3">
<h3 class="anchored" data-anchor-id="a-simple-function-for-valuing-a-derivative">A Simple Function for Valuing a Derivative</h3>
<p>To compute the expected value of a derivative, we need to evaluate the probability of each small interval on the <span class="math inline">\(x\)</span>-axis and multiply it by the corresponding derivative payoff. For a simple normally distributed variable, the probability of each interval can be approximated as:</p>
<div id="77a90cbd" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> stats.norm.pdf(x, mu, sigma) <span class="op">*</span> dx</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>However, as we saw when modeling the stock price process, the mean is not simply <span class="math inline">\(\mu\)</span>, and the volatility is not simply <span class="math inline">\(\sigma\)</span>. According to Equation <a href="#eq-final_price_model" class="quarto-xref">Equation&nbsp;43</a>, after adjusting for the time to maturity and the volatility correction, the mean of the log return becomes:</p>
<p><span id="eq-mean_stockprocess"><span class="math display">\[
(\mu - \tfrac{1}{2} \sigma^2) \cdot T
\tag{49}\]</span></span></p>
<p>Since we are working under the risk-neutral measure, we replace the expected return <span class="math inline">\(\mu\)</span> with the risk-free rate <span class="math inline">\(r\)</span>, resulting in:</p>
<p><span id="eq-riskneutral_mean"><span class="math display">\[
(r - \tfrac{1}{2} \sigma^2) \cdot T
\tag{50}\]</span></span></p>
<p>The corresponding volatility over the time horizon <span class="math inline">\(T\)</span> becomes:</p>
<p><span id="eq-volatility_scaled"><span class="math display">\[
\sigma \cdot \sqrt{T}
\tag{51}\]</span></span></p>
<p>With these substitutions, the discrete risk-neutral probability distribution used to price a derivative is:</p>
<div id="da70eae4" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> stats.norm.pdf(x, (r <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> T, sigma <span class="op">*</span> np.sqrt(T)) <span class="op">*</span> dx</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Using this setup, we can now define a simple and general function for computing the risk-neutral expected value of a derivative with terminal payoff <span class="math inline">\(f(S_T)\)</span>:</p>
<div id="ca4273d3" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> derivative_value_risk_neutral(f, S0, sigma, r, T, N<span class="op">=</span><span class="dv">1000</span>, width<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Numerically computes the risk-neutral value of a derivative with payoff function f(S_T).</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">    - f: Payoff function f(S_T)</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - S0: Initial stock price</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - sigma: Volatility</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - r: Risk-free interest rate</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - T: Time to maturity</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="co">    - N: Number of intervals for numerical integration</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="co">    - width: Number of standard deviations to cover on each side</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="co">    - Present value of the derivative</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    vol_T <span class="op">=</span> sigma <span class="op">*</span> np.sqrt(T)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    mu_T <span class="op">=</span> (r <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> T</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(<span class="op">-</span>width <span class="op">*</span> vol_T, width <span class="op">*</span> vol_T, N)</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    dx <span class="op">=</span> x[<span class="dv">1</span>] <span class="op">-</span> x[<span class="dv">0</span>]</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    ST <span class="op">=</span> S0 <span class="op">*</span> np.exp(x)</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> stats.norm.pdf(x, mu_T, vol_T) <span class="op">*</span> dx</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>    pv <span class="op">=</span> np.exp(<span class="op">-</span>r <span class="op">*</span> T) <span class="op">*</span> np.<span class="bu">sum</span>(f(ST) <span class="op">*</span> p)</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This function allows you to numerically evaluate the fair value of any derivative written on the terminal asset price <span class="math inline">\(S_T\)</span>, using risk-neutral expectations.</p>
<div id="3ed4927a" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> derivative_value_risk_neutral(f, S0, sigma, r, T, N <span class="op">=</span> <span class="dv">1000</span>, width <span class="op">=</span> <span class="dv">5</span>):</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"Calculates the risk neutral value of f"</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(<span class="op">-</span>width<span class="op">*</span>sigma<span class="op">*</span>(T<span class="op">**</span><span class="fl">0.5</span>), width<span class="op">*</span>sigma<span class="op">*</span>(T<span class="op">**</span><span class="fl">0.5</span>), N)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    dx <span class="op">=</span> width<span class="op">*</span>sigma<span class="op">*</span>(T<span class="op">**</span><span class="fl">0.5</span>)<span class="op">/</span>((N<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="fl">0.5</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> stats.norm.pdf(x, (r<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>T, sigma<span class="op">*</span>(T<span class="op">**</span><span class="fl">0.5</span>))<span class="op">*</span>dx</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    pv <span class="op">=</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>np.<span class="bu">sum</span>(f(S0<span class="op">*</span>np.exp(x))<span class="op">*</span>p)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="testing-the-derivative-valuation-function" class="level3">
<h3 class="anchored" data-anchor-id="testing-the-derivative-valuation-function">Testing the derivative valuation function</h3>
<p>Now, let us test if this function works. We can do that by comparing it with the known Black&amp;Scholes formula. The following defines the terminal value of the call option, and the Black&amp;Scholes formula:</p>
<div id="e4daa54c" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="dv">105</span>   <span class="co"># Strike price</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> call_option(ST):</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Call option payoff function</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.maximum(ST <span class="op">-</span> X, <span class="dv">0</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> black_scholes(S0, X, r, sigma, T):</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S0<span class="op">/</span>X) <span class="op">+</span> (r <span class="op">+</span> <span class="fl">0.5</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>)<span class="op">*</span>T)<span class="op">/</span>(sigma<span class="op">*</span>(T<span class="op">**</span><span class="fl">0.5</span>))</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma<span class="op">*</span>(T<span class="op">**</span><span class="fl">0.5</span>)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S0<span class="op">*</span>stats.norm.cdf(d1) <span class="op">-</span> X<span class="op">*</span>np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>stats.norm.cdf(d2)    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="9d3fc5f0" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.integrate <span class="im">as</span> integrate</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define parameters</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>S0 <span class="op">=</span> <span class="dv">100</span>  <span class="co"># Initial stock price</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span>  <span class="co"># Risk-free rate</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">0.2</span>  <span class="co"># Volatility</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Time to maturity (1 year)</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>f0_num <span class="op">=</span> derivative_value_risk_neutral(call_option, S0, sigma, r, T)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>f0_bs <span class="op">=</span> black_scholes(S0, X, r, sigma, T)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Numerical integral result: </span><span class="sc">{</span>f0_num<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Black-Scholes result: </span><span class="sc">{</span>f0_bs<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if the results are close    </span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.isclose(f0_num, f0_bs, atol<span class="op">=</span><span class="fl">1e-4</span>), <span class="st">"The results are not close!"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Numerical integral result: 8.021228881041875
Black-Scholes result: 8.021352235143176</code></pre>
</div>
</div>
<p>As we can see, our discrete valuation function works very well. With this simple approach, we can accurately value any contract written on the terminal asset price <span class="math inline">\(S_T\)</span>.</p>

</section>
</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bachelier1900" class="csl-entry" role="listitem">
Bachelier, Louis. 1900. <em>Théorie de La Spéculation</em>. Paris: Gauthier-Villars.
</div>
<div id="ref-jensen1906" class="csl-entry" role="listitem">
Jensen, Johan W. 1906. <span>“Sur Les Fonctions Convexes Et Les Inégalités Entre Les Valeurs Moyennes.”</span> <em>Acta Mathematica</em> 30: 175–93. <a href="https://doi.org/10.1007/BF02418571">https://doi.org/10.1007/BF02418571</a>.
</div>
<div id="ref-merton1971theory" class="csl-entry" role="listitem">
Merton, Robert C et al. 1971. <span>“Theory of Rational Option Pricing.”</span>
</div>
<div id="ref-scholes1973pricing" class="csl-entry" role="listitem">
Scholes, Myron, and Fischer Black. 1973. <span>“The Pricing of Options and Corporate Liabilities.”</span> <em>Journal of Political Economy</em> 81 (3): 637–54.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>